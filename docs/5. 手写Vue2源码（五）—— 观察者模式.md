## 前言
通过手写Vue2源码，更深入了解Vue；
在项目开发过程，一步一步实现Vue核心功能，我会将不同功能放到不同分支，方便查阅；
另外我会编写一些开发文档，阐述编码细节及实现思路；
源码地址：[手写Vue2源码](https://github.com/Shideshanxx/vue2-analyze)

## 问题分析
在上一节，页面初次渲染，我们调用了`vm._update(vm._render())`将VNode渲染到页面上；但是有一个问题：如果有一个异步方法修改了data，页面不会响应式更新。
思考一下怎么实现页面响应式更新？
1. 在修改数据时，我们需要知道哪些组件使用到该数据，以触发所有相关组件的视图更新；
2. 在执行`vm._render()`，获取数据时，我们需要给数据收集所有使用到该数据的组件；

## 流程分析
大概实现流程如下：
1. 在渲染组件时，实例化一个渲染watcher（后续利用watcher触发视图更新，以及绑定watcher与数据的关系）
2. 在触发数据的getter时，收集依赖（一个数据可能对应多个watcher，同时一个watcher可能对应多个数据）
3. 在触发数据的setter时，通知watcher更新视图（需要进行异步渲染优化）

在收集依赖时我们要做两件事：
+ 给数据收集相关watcher
+ 给watcher收集相关数据

为了实现这个功能，我们增加了一个中间者——dep：
1. dep和数据一一对应
2. dep必须唯一（一个watcher中可存放的多个dep，但dep必须唯一）
3. dep作为一个中间者，具体实现流程为：做数据劫持时实例化一个dep ——> 触发getter时通知dep收集watcher（`dep.depend(data)`）——> depend中通知watcher收集dep（`Dep.target.addDep(this)`，`Dep.target`在创建watcher时指向当前watcher）——> 在watcher中收集dep，并通知dep收集watcher（`dep.addSub(this)`）

## 创建渲染watcher
暂时只分析`渲染watcher`（`computed watcher`和`watch watcher`后续章节再分析）。
组件渲染时会执行`mountComponent()`，在该方法中实例化一个渲染watcher。
```js
// src/lifecycle.js
export function mountComponent(vm, el) {
  let updateComponent = () => {
    vm._update(vm._render());
  };
  // 每个组件渲染的时候，都会创建一个watcher，并执行updateComponent；true表示是渲染Watcher
  new Watcher(
    vm,
    updateComponent,
    () => {
      console.log('视图更新了')
      callHook(vm, "beforeUpdate");
    },
    true
  );
}
```

## 数据劫持中实例化dep、收集依赖、通知更新
直接看代码：
```js
// src/observer/index.js
function defineReactive(data, key, value) {
  observe(value);

  let dep = new Dep() // 为每个属性创建一个独一无二的dep
  Object.defineProperty(data, key, {
    get() {
      // Dep.target指向当前渲染watcher，只在渲染时存在，渲染完删除
      // 这里的判断是为了保证只在渲染时才进行依赖收集
      if(Dep.target) { 
        dep.depend() // 收集依赖
      }
      return value;
    },
    set(newVal) {
      if (newVal === value) return;
      observe(newVal);
      value = newVal;

      dep.notify(); // 通知dep存放的watchers去更新--派发更新
    },
  });
}
```

## 实现Dep
Dep实现的功能：
1. 唯一性
2. subs数组存放watchers
3. 通知watchers更新 —— notify()
4. 通知watcher收集dep —— depend()
5. 在dep中收集watcher —— addSub(watcher)
6. 创建自身的target属性，用来保存当前watcher

具体实现：
```js
// src/observer/dep.js
/**
 * 1. 每个属性我都给他分配一个dep（一对一的关系），一个dep可以存放多个watcher（一个属性可能对应多个watcher）
 * 2. 一个watcher中还可以存放多个dep（一个watcher可能对应多个属性，而dep与属性一一对应）
 * 3. dep具有唯一性
 */
let id = 0; // 给dep添加一个标识，保证它的唯一性
export default class Dep {
  constructor() {
    this.id = id++;
    this.subs = [];  // 用来存放watcher
  }

  // 将dep实例放到watcher中
  depend() {
    // 如果当前存在watcher
    if (Dep.target) {
      // Dep.target即当前watcher，是在new Watcher时设置的
      Dep.target.addDep(this); // this为dep实例（与属性一一对应），即把自身dep实例存放在watcher里面
    }
  }

  // 依次执行subs里面的watcher更新方法
  notify() {
    this.subs.forEach((watcher) => watcher.update());
  }

  // 把watcher加入到dep实例的subs容器（因为一个dep可能对应多个watcher）
  addSub(watcher) {
    this.subs.push(watcher);
  }
}

/**
 * targetStack定义在全局，为整个项目所有watcher
 * Dep.target定义在Dep自身而非prototype上，无法被实例继承，标识当前的watcher，具有唯一性
 */
// 栈结构用来存众多watcher
const targetStack = [];
// Dep.target 为 dep 当前所对应的watcher（即栈顶的watcher），默认为null
Dep.target = null;

export function pushTarget(watcher) {
  targetStack.push(watcher);
  Dep.target = watcher; // Dep.target指向当前watcher
}

export function popTarget() {
  targetStack.pop(); // 当前watcher出栈 拿到上一个watcher
  Dep.target = targetStack[targetStack.length - 1];
}
```

## 实现watcher
Dep实现的功能：
1. 实现页面渲染 —— `get()`，在`get()`调用`this.getter()`，即调用第二个形参（即`vm._update(vm._render())`）；在`get()`中配置`Dep.target`，进行入栈和出栈操作，保证渲染时的`Dep.target`指向当前watcher；
2. 页面更新 —— update()，需要进行**异步渲染优化**，后续再完善，暂时直接调用`this.get()`
3. 收集dep —— `addDep(dep)`，要确保dep的唯一性，另外在该方法中还要通知dep收集watcher

具体实现：
```js
// src/observer/watcher
export default class Watcher {
  constructor(vm, exprOrFn, cb, options) {
    this.vm = vm;
    this.exprOrFn = exprOrFn;
    this.cb = cb;
    this.options = options;

    this.deps = []; //存放dep的容器
    this.depsId = new Set(); //用来去重dep

    this.getter = exprOrFn;
    this.get();
  }

  // new Watcher时会执行get方法；之后数据更新时，直接手动调用get方法即可
  get() {
    // 把当前watcher放到全局栈，并设置Dep.target（无法继承，具唯一性）为当前watcher
    pushTarget(this);
    /**
     * 执行exprOrFn，如果watcher是渲染watcher，则exprOrFn为vm._update(vm._render())
     * 在执行render函数的时候，获取变量会触发属性的getter（定义在对象数据劫持中），在getter中进行依赖收集
     */
    const res = this.getter.call(this.vm);
    // 执行完getter就把当前watcher删掉，以防止用户在methods/生命周期中访问data属性时进行依赖收集（数据劫持时会判断Dep.target是否存在）
    popTarget(); // 在调用方法之后把当前watcher实例从全局watcher栈中移除，设置Dep.target为新的栈顶watcher
    return res;
  }

  /**
   * 1. 保证dep唯一，因为在render过程中，同一属性可能被多次调用，只需收集一次依赖即可；另外初始渲染收集过的dep，在更新时也不用再次收集（通过dep的id来判断）
   * 2. 将dep放到watcher中的deps数组中
   * 3. 在dep实例中添加watcher
   */
  addDep(dep) {
    let id = dep.id;
    if (!this.depsId.has(id)) {
      this.depsId.add(id);
      // 将dep放到watcher中的deps数组中
      this.deps.push(dep);
      console.log('watcher.deps------------', this.deps)
      // 直接调用dep的addSub方法  把自己watcher实例添加到dep的subs容器里面
      dep.addSub(this);
    }
  }

  // 更新当前watcher相关的视图
  update() {
    console.log('watcher.update：更新视图')
    this.get()
    // toDO... 如果短时间内同一watcher执行了多次update，我们希望先将watcher缓存下来，等一会儿一起更新
  }
}
```

## 流程图：
未完待续...
